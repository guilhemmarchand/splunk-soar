name: Publish to Splunk SOAR

on:
  push:
    branches:
      - testing
      - main

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: "3.x"

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r utils/requirements.txt

      - name: Determine Changes and Publish
        run: |
          echo "Inspecting git branch ${{ github.ref }}"
          commit_ids="${{ github.event.before }} ${{ github.sha }}"
          echo "Inspecting git commit ${{ github.sha }}"

          # Determine the target environment based on the branch
          if [[ "${{ github.ref }}" == "refs/heads/testing" ]]; then
              echo "Environment target is Testing"
              DEST_API_URL=$SOAR_TESTING_DEST_API_URL
              DEST_API_TOKEN=$SOAR_TESTING_DEST_API_TOKEN
              DEST_SCM_NAME=$SOAR_TESTING_DEST_SCM_NAME
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              echo "Environment target is Production"
              DEST_API_URL=$SOAR_PROD_DEST_API_URL
              DEST_API_TOKEN=$SOAR_PROD_DEST_API_TOKEN
              DEST_SCM_NAME=$SOAR_PROD_DEST_SCM_NAME
          else
              echo "Invalid branch. This workflow is only for 'testing' or 'main' branches, refusing to excute this against any other branch."
              exit 1
          fi

          # Extract the pairs of modified files
          modified_files=$(git diff --name-only $commit_ids)
          IFS=$'\n' read -d '' -r -a files_array <<< "$modified_files"

          for ((i=0; i<${#files_array[@]}; i+=2)); do
              # Pair files by two
              file1="${files_array[i]}"
              file2="${files_array[i+1]}"
              
              # Only process pairs that have .json and .py
              if [[ "$file1" =~ \.json$ && "$file2" =~ \.py$ ]] || [[ "$file1" =~ \.py$ && "$file2" =~ \.json$ ]]; then
                  valid_pair=("$file1" "$file2")
                  
                  # Determine base name for tarball
                  base_name="${file1%.*}" # strip extension
                  
                  # Determine the object type and create tarball
                  tarball_path="/tmp/$base_name.tgz"
                  if echo "${valid_pair[*]}" | grep -q 'custom_functions/'; then
                      OBJECT_TYPE="custom_function"
                      
                      # Debugging output
                      echo "Creating tarball for custom_function at path: $tarball_path with files: ${valid_pair[*]}"
                      
                      (cd custom_functions && tar -czvf "$tarball_path" "${valid_pair[@]}")
                  else
                      OBJECT_TYPE="playbook"
                      
                      # Debugging output
                      echo "Creating tarball for playbook at path: $tarball_path with files: ${valid_pair[*]}"
                      
                      tar -czvf "$tarball_path" "${valid_pair[@]}"
                  fi

                  echo "Running command: python3 utils/soar_publish.py --input_file \"$tarball_path\" --dest_target=\"$DEST_API_URL\" --dest_token=\"$DEST_API_TOKEN\" --dest_scm_name=\"$DEST_SCM_NAME\" --object_type \"$OBJECT_TYPE\""
                  python3 utils/soar_publish.py --input_file "$tarball_path" --dest_target="$DEST_API_URL" --dest_token="$DEST_API_TOKEN" --dest_scm_name="$DEST_SCM_NAME" --object_type "$OBJECT_TYPE"
              else
                  echo "Invalid file pair detected: $file1 and $file2. Skipping."
              fi
          done
        env:
          SOAR_TESTING_DEST_API_URL: ${{ secrets.SOAR_TESTING_DEST_API_URL }}
          SOAR_TESTING_DEST_API_TOKEN: ${{ secrets.SOAR_TESTING_DEST_API_TOKEN }}
          SOAR_TESTING_DEST_SCM_NAME: ${{ secrets.SOAR_TESTING_DEST_SCM_NAME }}
          SOAR_PROD_DEST_API_URL: ${{ secrets.SOAR_PROD_DEST_API_URL }}
          SOAR_PROD_DEST_API_TOKEN: ${{ secrets.SOAR_PROD_DEST_API_TOKEN }}
          SOAR_PROD_DEST_SCM_NAME: ${{ secrets.SOAR_PROD_DEST_SCM_NAME }}
